# 컴퓨터과학개론

## 5강. 알고리즘 (1)

### 알고리즘 개념

#### 알고리즘?

##### > 문제 해결을 위한 레시피

- 효율적인 문제 해결을 위한 방법

##### > 주어진 문제를 풀기 위한 명령어들을 단계적으로 나열한 것

- 입출력
  - 0개 이상의 외부 입력, 1개 이상의 출력
- 명확성
- 유한성
- 유효성

#### 알고리즘 생성 단계

- 설계
- 표현/기술
- 정확성 검증
- 효율성 검증

#### 자료구조와 알고리즘의 관계

##### > 자료구조

- 데이터 사이의 논리적 관계를 표현하고 조직화하는 방법

##### > 효율적 프로그램 -> 자료구조 + 알고리즘

- 두 가지가 적절하게 조화되었을 때, 효율적 프로그램

#### 알고리즘 설계 기법

##### > 대표적인 설계 기법

- 분할 정복 방법
- 동적 프로그래밍 방법
- 욕심쟁이 방법

#### 분할 정복 방법

##### > 순환적으로 문제를 푸는 방법

- 문제의 입력을 더 이상 나눌 수 없을 때까지 두 개 이상의 작은 문제로 순환적으로 분할하고, 분할된 문제들을 각각 해결한 후 이들의 해를 결합하여 원래 문제의 해를 구하는 하향식 접근 방법

##### > 각 순환마다 세 단계의 처리 과정을 거침

- 분할
- 정복
- 결합

##### > 퀵 정렬, 합병 정렬, 이진 탐색

#### 동적 프로그래밍 방법

##### > 최적화 문제의 해를 구하기 위한 상향식 접근 방법

- 문제의 크기가 작은 소문제에 대한 해를 구해서 테이블에 저장해 놓고, 이를 이용하여 크기가 보다 큰 문제의 해를 점진적으로 만듦

#### 욕심쟁이 방법

##### > 해를 구하는 일련의 선택 과정마다 전후 단계의 선택과는 상관없이 각 단계에서 가장 최선이라고 여겨지는 국부적인 최적해를 선택해 나가면 결과적으로 전체적인 최적해를 얻을 수 있을 것이라고 희망하는 방법

- 적용 범위는 제한적이나 간단하면서도 강력한 설계 기법을 만들 수 있음

#### 알고리즘 분석

##### > 정확성 분석

- 유효한 입력, 유한 시간 -> 정확한 결과 생성
  - 다양한 수학적 기법을 사용한 이론적 증명이 필요
  - 따라서 수업 때 이 부분에 대한 분석은 하지 않음

##### > 효율성 분석

- 알고리즘 수행에 필요한 컴퓨터 자원의 양을 측정
  - 메모리 양 -> 공간 복잡도
  - 수행 시간 -> 시간 복잡도

#### 시간 복잡도

##### > 알고리즘의 수행 시간

- 컴퓨터에서 실행시켜 완료될 때까지 걸리는 실제 시간을 측정
- 일반성이 결여되기 때문에 의미 없음

##### > 알고리즘에서 단위 연산의 수행 횟수를 모두 더한 값

- 입력 크기가 증가하면 수행 시간도 증가
  - 단순히 단위 연산의 개수가 아닌 입력 크기의 함수로 표현
- 입력 데이터의 상태에 종속적
  - 평균 수행 시간
  - 최선 수행 시간
  - **최악 수행 시간**

#### 점근 성능

##### > 입력 크기 n이 충분히 커짐에 따라 결정되는 성능

다항식의 수행 시간에서 가장 큰 영향을 미치는 것이 최고차항

수행 시간의 어림값, 수행 시간의 증가 추세 -> 알고리즘간의 우열을 판단할 수 있음

#### 점근 성능의 표기법

c*g(n) 은 계수가 있는 경우를 표현

오메가는 최선의 수행 시간

세타는 최악보다는 빠르고 최선 보다는 오래 걸리는 경우

### 정렬 알고리즘

#### 기본 개념

- 내부 정렬
  - 모든 데이터를 주기억장치에 적재한 후 정렬하는 방식

- 외부 정렬
  - 일부 데이터는 주기억 장치, 나머지는 외부기억장치에 저장한 후 정렬하는 방식

일반적으로 알고리즘에 정렬은 내부 정렬을 의미

#### 비교 기반

- O(n^2)
  - 선택 정렬
  - 버블 정렬
  - 삽입 정렬
- O(n*logn) 위 정렬을 개선한 것
  - 퀵 정렬
  - 합병 정렬

#### 분포 기반

- 데이터들이 어떤 분포적인 특성을 가지고 있는지 사전에 확인 후 정렬에 활용
- 일반성이 떨어지는 정렬

#### 선택 정렬

주어진 데이터 중에서 가장 작은 값부터 차례대로 선택해서 나열하는 방식

데이터의 입력 상태에 민감하지 않은 수행 시간

#### 버블 정렬

##### > 왼쪽에서부터 모든 인접한 두 데이터를 차례대로 비교하여 왼쪽의 값이 더 큰 경우에는 오른쪽 값과 자리를 바꾸는 과정을 통해 정렬

데이터가 정렬됨을 확인한 이후에는 다음 정렬 단계를 수행할 필요가 없음

데이터가 역순으로 정렬되어있는 경우 최악의 경우로 O(n^2) 만큼이 걸림

선택 정렬에 비해 데이터 교환이 더 많이 발생.  비효율적

#### 삽입 정렬

##### > 뽑은 데이터가 삽입될 제자리를 찾는 과정

맨 앞 데이터는 정렬되었다고 가정, 그 이후 데이터부터 그 앞 데이터와 비교 시작

##### > 특징

- 이미 정렬되어 있는 경우
  - 최선의 경우 O(n)
- 역순으로 정렬되어 있는 경우
  - 최악의 경우 O(n^2)
