# 컴퓨터과학개론

## 6강. 알고리즘 (2)

### 정렬 알고리즘

#### 1) 퀵 정렬

##### > 특정 데이터를 기준으로 입력 배열을 두 부분배열로 분할하고, 각 부분배열에 대해서 독립적으로 퀵 정렬을 순환적으로 적용하는 방식

- 평균적으로 가장 좋은 성능의 비교 기반 알고리즘 -> O(nlogn)

##### > 피벗

- 두 개의 부분배열로 분할할 때 기준이 되는 데이터
- 주어진 배열의 첫 번째 원소

##### > 피벗이 제자리를 잡도록 하여 정렬하는 방식

- L이 피벗보다 큰 값을 찾을 때까지 이동
- R이 피벗보다 작은 값을 찾을 때까지 이동
- 서로 위치를 바꿔줌
- 바꿔준 위치에서부터 다시 비교를 시작
- L과 R이 교차하는 경우, R과 피벗을 교체한 후 종료

##### > 특징

- 분할정복 방법

##### > 성능

- 분할 과정의 수행 시간 -> O(n), 데이터 개수에 비례
- 최선 수행 시간 -> O(nlogn)
  - 피벗을 중심으로 항상 동일한 크기의 두 개의 부분배열로 분할되는 경우
- 최악 수행 시간 -> O(n^2)
  - 피벗만 제자리를 잡고 나머지 모든 데이터가 하나의 부분배열로 분할되는 경우
  - 내림차순 혹은 오름차순으로 정렬
  - 1:n-1 혹은 n-1:1로 분할
  - 피벗이 배열에 항상 최대값 또는 최소값이 되는 경우
  - 입력 데이터가 이미 정렬되어 있고, 피벗을 맨 왼쪽 원소로 지정한 경우
  - 피벗 선택의 임의성만 보장되면 평균 수행 시간을 보일 가능성이 높음
  - 평균 수행 시간이 가장 빠른 알고리즘

#### 2) 합병 정렬

##### > 동일한 크기의 두 개의 부분배열로 분할하고, 각 부분배열을 순환적으로 정렬한 후 정렬된 두 부분배열을 합병하나 하나의 정렬된 배열을 만드는 방식

##### > 합병 과정

- 두 배열의 원소를 비교하고 작은 값을 새로운 배열에 추가
- 한 배열이 다 처리되고 나면, 다른 배열이 남게 됨. 그 배열은 그대로 새로운 배열에 추가해주면 됨
- 분할 정복 방법을 적용한 알고리즘

##### > 최선, 최악, 평균 수행 시간 -> O(nlogn)

### 순차 탐색, 이진 탐색

#### 1) 탐색의 개념

순차 탐색 O(n), 최악의 성능

이진 탐색 O(longn), 최고 성능

이진 탐색 트리 O(logn) 최악의 경우 O(n)이 걸리기도 함

#### 2) 순차 탐색

##### > 특징

- 데이터가 키값과 관련해서 아무런 순서 없이 단순하게 연속적으로 저장된 경우에 적합
- 데이터가 정렬되지 않은 경우에 적합
- 각 탐색 기법은 상황에 따라 그 효율성이 다름

#### 3) 이진 탐색

##### > 정렬된 입력 배열에 대해서 주어진 데이터를 절반씩 줄여가면서 원하는 데이터를 찾는 방법

##### > 탐색 방법

- 입력 배열의 가운데 값과 탐색키를 비교
  - 탐색키 = 배열의 가운데 값
    - 탐색 성공
  - 탐색키 < 배열의 가운데 값
    - 배열의 전반부 이진 탐색 진행
  - 탐색키 > 배열의 가운데 값
    - 배열의 후반부 이진 탐색 진행

##### > 성능 -> O(logn)

- 한 번 탐색할 때마다 탐색 대상이 되는 데이터 개수가 반으로 감소

##### > 특징

- 데이터가 이미 정렬된 경우에만 적용
- 정렬 상태를 유지하기 위해 삽입, 삭제 연산시 추가 연산이 발생
- 삽입 삭제 빈번한 응용 분야에는 부적합
- 이 문제를 해결하기 위해 이진 탐색 트리 사용

## 이진 탐색 트리

#### 1) 이진 탐색 트리

##### > 이진 트리

- 각 노드의 왼쪽 서브트리에 있는 모든 키값은 그 노드의 키값보다 작다.
- 각 노드의 오른쪽 서브트리에 있는 모든 키값은 그 노드의 키값보다 크다.

#### 2) 탐색 연산

모든 트리에 대한 연산은 루트 노드로부터 시작

#### 3) 삽입 연산

##### > 삽입할 데이터를 탐색한 후, 탐색이 실패한 위치에 새로운 노드를 자식 노드로 추가

- 탐색 성공의 경우, 삽입 없이 종료

#### 4) 삭제 연산

##### > 후속자 노드

- 어떤 노드의 키값보다 바로 다음으로 큰 키값을 가지는 노드

##### > 삭제되는 노드의 자식 노드의 개수에 따라 구분해서 처리

- 자식 노드가 없는 경우
  - 남은 노드의 위치 조절이 불필요
- 자식 노드가 하나인 경우
- 자식 노드가 두 개인 경우

#### 성능

##### > 키값의 비교 횟수에 비례 트리의 높이가 h라면 O(h)

- 모든 노드의 차수가 2인 경우(리프 노드 제외)
  - 평균 수행 시간 O(logn)
- 경사 이진 트리
  - 모든 노드의 차수가 1인 경우
  - 최악 수행 시간 O(n)
