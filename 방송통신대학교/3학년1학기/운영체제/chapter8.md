# 운영체제

## 메모리 관리

### 프로세스와 메모리

#### 프로세스의 동작

- 프로그램 카운터를 참조하여 수행될 명령을 메모리에서 읽어 CPU로 수행하는 것
- 운영체제도 프로세스
- 그외 프로세스가 특정 메모리 주소상에 위치
- 프로세스 주소(프로그램 카운터가 가리키고 있음)의 첫 지점부터 프로그램 카운터가 명령어를 계속 확인하며 CPU에 전달
- 메모리는 컴퓨터의 전원을 끄고 나면 사라짐
- 기본적으로 프로그램은 보조기억장치의 특정 위치에 자리함.
- 프로그램의 크기가 너무 크면, 프로그램 상당 부분을 보조기억장치에 위치해놓고, 일부만 메모리에 올려놓는 식으로 실행할 수도 있음
- 보조기억장치는 메모리보다 속도가 느림.
- 반복문 등이 실행될 때는 캐시 메모리를 사용하면 속도가 좀 더 빠름

#### 기억장치 계층구조

- 적절한 비용으로 높은 성능을 냄

  - CPU(레지스터)
  - 캐시 메모리
  - 메모리
  - 보조 기억장치

  실제로는 CPU와 메모리만 있으면 실행에는 문제가 없음

  추가적으로 공간이 필요하다면 보조 기억장치를 사용

  메모리보다 속도를 내고 싶다면 캐시 메모리를 사용

  레지스터도 특정 공간이라고 할 수 있음. 레지스터의 속도가 가장 빠름

- 레지스터부터 아래로 내려갈수록 접근속도가 빠름
- 레지스터부터 아래로 내려갈수록 비트당 기억장치 비용이 낮음
- 무조건 속도가 빠른 레지스터만 사용할 수는 없음
- 보조 기억장치로 갈수록 용량이 커짐

#### 메모리 관리

- 메모리 호출
  - 언제 새로운 프로세스를 메모리에 둘 것인가?
  - 시점을 다룸
- 메모리 배치
  - 다음에 실행될 프로세스를 메모리 내의 어느 곳에 둘 것인가?
- 메모리 교체
  - 메모리가 꽉 찬 상태에서 새로운 프로세스를 메모리에 적재해야 한다면 어떤 프로세스를 제거할 것인가
- 그 외 : 고정/동적 분할, 고정.유동 적재영역 등

### 단일 프로그래밍 환경

#### 단일 프로그래밍

- 하나의 프로세스만 메모리를 전용으로 사용하는 것
- 초창기에 사용되었던 방식
- 프로세스는 하나의 연속된 블록으로 메모리에 할당
  - 연속 메모리 할당

#### 단일 프로그래밍의 문제점

- 메모리의 용량을 초과하는 프로세스는 실행 못함
- 메모리 낭비 심함
  - 지속적으로 사용되지 않는 프로세스도 메모리에 계속 적재
- 주변장치 등 자원의 낭비 심함
  - 계산 위주의 사용자 프로세스
  - 입출력 장치들은 거의 사용되지 않더라도, 하나의 프로그램만 동작하기 때문에 아무런 동작도 하지 않고 자원이 낭비됨.
  - 반대로 입출력 장치의 사용이 많다면, CPU이 낭비됨.

### 다중 프로그래밍 환경

- 여러 개의 프로세스가 메모리에 동시에 적재되는 것
- CPU 연산과 입출력을 동시에 함으로써 CPU 이용도와 시스템 처리량 증가

#### 메모리 분할

- 여러 프로세스를 메모리에 적재하기 위해 고안된 방법
- 하나의 분할에 하나의 프로세스가 적재되는 방식
- 종류 : 고정 분할, 동적 분할

#### 고정 분할

- 메모리를 여러 개의 고정된 크기의 영역으로 분할
- 프로세스 배치 방법1
  - 분할영역마다 큐를 두고 큐에 들어온 프로세스는 해당 분할영역에만 적재
  - 절대 번역 및 적재
    - 절대 주소를 사용
    - 효율성 낮음
      - 특정분할에서 대기하는 프로세스들은 그 분할에서만 실행될 수 있기 때문에 다른 분할들이 비어있어도 사용할 수가 없음
- 프로세스 배치 방법 2
  - 하나의 큐만 두고 큐에 들어온 프로세스는 어느 분할영역에든 적재
  - 재배치 가능 번역 및 적재
    - 상대주소를 사용
    - 
  - 복잡함

- 문제점 : 내부 단편화
  - 프로세스의 크기가 적재된 분할영역의 크기보다 작아서 분할영역 내에 남게 되는 메모리 발생
  - 가령 분할된 메모리의 크기가 60mb 일 때 실행될 프로세스의 크기가 41mb면 19mb가 남게됨
  - 수행할 프로세스의 크기를 미리 알고 그에 맞춰 고정 분할을 하면 이를 해결 가능
  - 이는 현실적이지 못함

#### 동적 분할

- 메모리의 분할경계가 고정되지 않음
- 각 프로세스에 필요한 만큼의 메모리만 할당
- 문제점 : 외부 단편화
  - 메모리의 할당과 반환이 반복됨에 따라 작은 크기의 공백이 메모리 공간에 흩어져 생김
- 통합
  - 인접된 공백을 더 큰 하나의 공백으로 만들어 외부 단편화 해결
- 집약
  - 메모리 내의 모든 공백을 하나로 모아 외부 단편화 해결
  - 집약을 위해서는 프로세를 옮겨야 함
  - 매번 사용하기는 쉽지 않고, 적당한 시점에 한 번씩 모아주는 정도

#### 메모리 보호

- 프로세스가 다른 할당영역을 침범하지 않게 하는 것
- 하한 ~ 상한 또는 하한 ~ 크기 레지스터 쌍으로 제한
- 이 제한 넘어 운영체제 호출하려면 시스템 호출 이용

### 메모리 배치기법

- 동적 분할 다중 프로그래밍에서 새로 반입된 프로그램이나 데이터를 메모리의 어느 위치에 배치할 것인가를 결정
- 종류
  - 최초 적합
    - 프로세스가 적재될 수 있는 빈 공간 중에서 가장 먼저 발견되는 곳을 할당
  - 후속 적합
    - 최초 적합의 변형
    - 이전에 탐색이 끝난 그 다음부터 시작해서 사용 가능한 빈 공간 중에서 가장 먼저 발견되는 곳을 할당
  - 최적 적합
    - 필요한 공간을 제공할 수 있는 빈 공간 중 가장 작은 곳을 선택해 할당
    - 큰 빈 공간을 최대한 많이 남겨 놓기 위한 방법
    - 거의 모든 공백을 찾아봐야 함
  - 최악 적합
    - 필요한 공간을 제공할 수 있는 빈 공간 중 가장 큰 곳을 선택하여 할당
    - 작은 자투리가 남아 사용되지 못하는 공간이 발생하는 것을 최소화하기 위한 방법
