# Java 프로그래밍

## 기말고사 대비

### 익명 클래스 정의

```java
CSuper sub = new CSuper() {
	public int b = 20;
}
```

이 코드는 `CSuper` 클래스를 상속받은 익명 클래스를 정의하고, 이를 사용하여 `CSuper` 클래스의 객체를 생성하는 예시입니다.

여기서 `CSuper` 클래스는 `sub`라는 변수명으로 객체를 생성하고 초기화하고 있습니다. 익명 클래스는 `new CSuper() { ... }` 구문을 사용하여 생성됩니다. 중괄호 안에는 해당 익명 클래스의 멤버를 정의할 수 있습니다.

이 익명 클래스는 `CSuper` 클래스를 상속하고 있으며, 추가적인 멤버로 `b`라는 `int` 타입의 변수를 선언하고 초기값으로 20을 할당하고 있습니다. 이렇게 하면 `sub` 객체의 `b` 변수에 접근할 수 있습니다.

익명 클래스를 사용하는 이유는 `CSuper` 클래스를 상속받아 재정의하거나, 추가적인 멤버를 정의하기 위해서입니다. 익명 클래스는 일회성으로 사용되는 클래스이며, 특정한 목적에 맞게 임시로 사용할 때 유용합니다.

### 제네릭 컴파일 오류

```java
String s1 = list1.get(0);
```

컴파일 오류가 발생하는 이유는 `ArrayList`의 `get()` 메서드의 반환 타입이 `Object`입니다. 즉, `list1.get(0)`는 `Object`를 반환합니다. 따라서 `String` 타입의 변수에 직접 할당할 수 없습니다.

### String 클래스 효율성

`String` 클래스는 불변(immutable) 클래스로 알려져 있습니다. 이는 `String` 객체가 생성된 후에는 해당 객체의 내용을 변경할 수 없음을 의미합니다. 따라서 문자열을 변경해야 할 경우에는 새로운 `String` 객체를 생성해야 합니다.

문자열을 빈번하게 변경하는 프로그램에서는 `String` 클래스를 사용하는 대신 `StringBuilder` 또는 `StringBuffer` 클래스를 고려하는 것이 일반적으로 더 효율적입니다. 이 클래스들은 가변(mutable)하며 문자열을 변경하는 작업에 특화되어 있습니다.

`StringBuilder`와 `StringBuffer` 클래스는 문자열을 변경할 때 내부 버퍼를 사용하여 문자열을 효율적으로 조작합니다. 새로운 문자열을 생성하지 않고도 기존 문자열에 추가하거나 수정할 수 있습니다. 이는 문자열 변경 작업을 빠르고 메모리 사용을 효율적으로 처리할 수 있게 해줍니다.

따라서, 문자열을 빈번하게 변경해야 하는 프로그램에서는 `StringBuilder` 또는 `StringBuffer` 클래스를 사용하는 것이 `String` 클래스보다 실행 효율면에서 더 좋은 선택일 수 있습니다.

### 박싱

Java에서 `Integer`은 기본 데이터 타입인 `int`의 래퍼 클래스(Wrapper Class)입니다. 이것은 `int` 값을 객체로 표현하기 위한 클래스입니다. `new Integer(10)`은 `10`이라는 정수 값을 가지는 `Integer` 객체를 생성하는 것입니다.

박싱(Boxing)은 기본 데이터 타입의 값을 해당하는 래퍼 클래스 객체로 변환하는 과정을 말합니다. 즉, `int` 값을 `Integer` 객체로 변환하는 것이 박싱입니다. 이 경우에는 `10`이라는 `int` 값을 `new Integer(10)`을 통해 `Integer` 객체로 박싱하고, 그 결과를 `i` 변수에 할당합니다.

반대로, 언박싱(Unboxing)은 래퍼 클래스 객체를 해당하는 기본 데이터 타입으로 변환하는 과정을 말합니다. Java에서는 자동으로 박싱과 언박싱을 처리해주는 기능을 제공합니다.

Java 5 이후 버전부터는 오토박싱(AutoBoxing)이라는 개념이 도입되어, 기본 데이터 타입과 그에 해당하는 래퍼 클래스 간의 자동 변환을 제공합니다. 따라서, 위 코드에서는 `10`이라는 `int` 값을 `Integer` 객체로 자동으로 박싱하여 변수 `i`에 할당됩니다.

### PrintWriter

`FileWriter` 클래스는 Java의 `java.io` 패키지에 속하는 파일 기반의 문자 스트림을 처리하기 위한 클래스입니다. `FileWriter` 클래스는 `Writer` 클래스를 상속하며, 파일에 텍스트 데이터를 쓰는 데 사용됩니다.

`FileWriter` 클래스는 파일에 문자 기반 데이터를 쓸 때 유용하게 사용되며, 파일을 생성하고 수정하는 등의 작업을 수행할 수 있습니다.

### Path

`Path` 인터페이스는 Java의 `java.nio.file` 패키지에 속하는 파일 및 디렉터리 경로를 다루기 위한 인터페이스입니다. `Path` 인터페이스는 파일 시스템에서 경로를 나타내고 조작하는 기능을 제공합니다.

`Path` 인터페이스는 파일 및 디렉터리 경로의 생성, 접근, 탐색, 검색, 삭제 등 다양한 작업을 수행할 수 있는 메서드를 제공합니다. 이를 통해 파일 경로를 조작하고 파일 시스템 작업을 수행할 수 있습니다.

`Path` 인터페이스를 사용하여 파일 내용의 읽기와 쓰기 기능은 직접 제공하지 않습니다. 그러나 `Path` 인터페이스를 활용하여 파일을 실제로 읽고 쓸 수 있는 `Files` 클래스의 메서드를 사용할 수 있습니다.

`Files` 클래스는 Java의 `java.nio.file` 패키지에 속하는 파일과 디렉터리를 다루는 유틸리티 클래스입니다. `Files` 클래스는 `Path` 인터페이스를 활용하여 파일의 내용을 읽고 쓰는 기능을 제공합니다.

### Thread.join

스레드가 종료될 때까지 기다리기 위해 사용하는 메서드는 `join()`입니다. `join()` 메서드는 현재 실행 중인 스레드가 대상 스레드가 종료될 때까지 기다리도록 합니다.

`join()` 메서드는 스레드 객체에 호출되며, 해당 스레드가 종료될 때까지 호출한 스레드는 일시적으로 대기 상태가 됩니다. 종료되면 `join()` 메서드는 반환되고 호출한 스레드는 실행을 계속합니다.

### Thread.yield

Thread.yield() 메서드는 현재 실행 중인 스레드를 일시적으로 일시 중단하고 다른 스레드에 실행 기회를 주는 데 사용되는 Java 스레드 제어 메서드입니다.

일반적으로 운영체제의 스케줄러가 스레드를 제어하고 스레드 실행 시간을 할당하지만, 때로는 우선 순위가 낮은 스레드가 우선 순위가 높은 스레드에 비해 공정한 실행 기회를 받을 수 없는 상황이 발생할 수 있습니다.

Thread.yield() 메서드는 이러한 상황에서 현재 실행 중인 스레드를 일시 중단하고 다른 스레드에게 실행 기회를 양보합니다. 이 메서드를 호출한 스레드는 실행 대기 상태로 전환되며, 스레드 스케줄러는 다른 실행 가능한 스레드를 선택하여 실행합니다. 다른 스레드가 실행을 마칠 때까지 현재 스레드는 일시 중단된 상태로 유지됩니다.

#### 배열 중괄호 초기화

Java에서 배열을 초기화할 때, 중괄호(`{}`)를 사용한 배열 초기화는 배열을 선언과 동시에 초기화할 때만 사용할 수 있습니다.

#### println 오버로드

주어진 코드에서 `System.out.println(i, j);` 구문이 문제를 일으키는 이유는 `println()` 메서드의 오버로드된 형식 중 하나를 잘못 사용했기 때문입니다.

`println()` 메서드는 매개변수로 전달된 값을 출력하는 역할을 합니다. 그러나 `println()` 메서드는 매개변수를 한 개만 받을 수 있습니다. 즉, `println()` 메서드를 호출할 때는 한 개의 값만 전달해야 합니다.

주어진 코드에서 `System.out.println(i, j);`를 호출하면 컴파일 오류가 발생합니다. 올바른 방법은 두 변수의 값을 출력하기 위해 문자열로 변환한 후, 하나의 인자로 `println()`에 전달하는 것입니다.

#### 클래스 파일 개수

```java
class CSuper {
    public int a = 10;
}


public class AnonymousTest
{
    public static void main(String[] args) {
        CSuper sub = new CSuper() {
            public int b = 20;
        }
	}
}
```

주어진 코드를 컴파일하면 두 개의 클래스 파일이 생성됩니다.

1. `CSuper.class`: `CSuper` 클래스의 컴파일된 바이트 코드가 포함된 클래스 파일입니다. 이는 `CSuper` 클래스의 정의에 대한 클래스 파일입니다.
2. `AnonymousTest.class`: `AnonymousTest` 클래스의 컴파일된 바이트 코드가 포함된 클래스 파일입니다. 이는 `main` 메서드와 `AnonymousTest` 클래스의 정의에 대한 클래스 파일입니다.

`AnonymousTest` 클래스 내부에서 `CSuper`를 상속하고 익명 클래스를 생성하였지만, 이 익명 클래스는 컴파일 시에 이름이 없는 별도의 클래스 파일로 생성되지 않습니다. 대신에, 컴파일러는 `AnonymousTest` 클래스의 바이트 코드에 익명 클래스의 정의를 포함시킵니다.

따라서 위 코드를 컴파일하면 `CSuper.class`와 `AnonymousTest.class` 두 개의 클래스 파일이 생성됩니다.

#### Synchronized

`synchronized` 키워드는 메서드의 반환 타입 앞에 위치해야 합니다.

`synchronized` 키워드는 Java에서 동기화를 달성하기 위해 사용되는 키워드입니다. 다중 스레드 환경에서 공유된 데이터나 리소스에 접근할 때 동기화를 제공하여 스레드 간의 안전성을 보장합니다.

`synchronized` 키워드를 사용하면 다음과 같은 기능을 수행합니다:

1. 상호 배제 (Mutual Exclusion): `synchronized` 키워드를 가진 메서드나 블록은 한 번에 하나의 스레드만 실행할 수 있도록 합니다. 이는 여러 스레드가 동일한 데이터에 동시에 접근하는 것을 방지합니다.
2. 가시성 보장 (Visibility Guarantee): `synchronized` 블록 내에서 변경된 변수의 값을 다른 스레드에게 즉시 알립니다. 다른 스레드는 항상 가장 최신의 값을 읽을 수 있습니다.

`synchronized` 키워드는 과도한 동기화로 인한 성능 저하를 야기할 수 있으므로 필요한 부분에만 적절하게 사용하는 것이 좋습니다. Java 5부터는 `java.util.concurrent` 패키지에서 제공하는 동기화 기법을 활용하는 것이 더 선호되며, `synchronized` 키워드를 직접 사용하는 경우는 상대적으로 적어졌습니다.
