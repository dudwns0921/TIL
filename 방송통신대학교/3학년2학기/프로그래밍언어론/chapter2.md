# 프로그래밍 언어론

## 2강. 프로그래밍 언어의 발전 및 동작원리

### 1) 프로그래밍 언어의 발전

#### 1950년대 : 초기 프로그래밍 언어

##### Fortran : 수식과 문장, 제어문 등장

- 과학계산용 언어
- 기계어가 아닌 사용자가 사용하기 쉬운 고급어

##### Algol: 구조화 프로그래밍의 발전

- 알고리즘 기술 언어
- begin, end 등장

##### LISP : 초기 함수형 언어

- 최초의 함수형 언어
- 데이터와 프로그램이 동일한 형태
- 가령 A라는 프로그램을 B라는 프로그램에 전달해 데이터처럼 활용 가능
- 프로그램이 프로그램을 자체적으로 변경, 인공지능 분야에서 활용

##### Cobol : 레코드 타입의 소개

- 사무용 언어
- 레코드는 서로 다른 타입의 자료들도 한묶음으로 표현할 수 있음

#### 1970년대 : 프로그래밍 언어의 단순화

##### C : 진정한 시스템 프로그래밍 언어

- Unix 개발용 시스템 프로그래밍 언어
- 하드웨어와 사용자를 중간에 연결해주는 언어
- 다양한 언어에 지대한 영향을 끼침

#### 1980년대 : 현대 프로그래밍 언어 등장

##### Common Lisp : 방대한 LISP의 통합

##### Objective-C : C의 탈을 쓴 Smalltalk

- C를 기초로 한 객체지향 언어의 신호탄
- Apple 애플리케이션 작성 언어로 발전

##### C++ : 객체지향으로 변신한 C

- 클래스 개념을 C에 도입

#### 1990년대 : 프로그래밍 언어의 대중화

브라우저에서 동작하는 언어가 각광받던 시대

##### Java : 단순한 객체지향 언어

- 원래 목적은 임베디드 컴퓨팅 분야였으나 웹 브라우저에 탑재되면서 인기

##### Javascript : 웹 프로그래밍 언어

##### Python : 빠른 프로토타이핑 언어

- 동적 언어를 추구
- 다중 패러다임 언어 : 명령형, 객체지향 등

### 2) 프로그램 동작 원리

#### 컴퓨터 구조와 프로그램 동작 원리

##### 컴퓨터 구조

- CPU와 메모리, 저장장치 등이 BUS로 연결
- 다양한 입출력 장치도 BUS에 연결될 수 있음
- 전원 : 운영체제 적재 (저장장치에서 메모리로 적재)
- CPU는 인출 - 해석 - 실행 주기를 반복하여 메모리의 명령어를 실행

##### 기계어

- CPU가 이해하고 수행하는 명령어
- 이진수 형태의 명령어를 사람이 이해하는 것은 매우 난해

##### 어셈블리어

- 기계어에 거의 일대일 대응하는 형태의 기호 언어
- CPU에 종속적
- 이식성이 거의 없음

##### 고급 프로그래밍 언어

- 사람이 쉽게 이해 가능
- 특정 기계에 종속적이지 않음

- 프로그램을 CPU가 알아듣는 기계어로 표현해주어야 함
  - 소스 프로그램 : 프로그래머가 작성한 프로그램
  - 목적 프로그램 : 컴퓨터 하드웨어가 수행할 수 있는 프로그램

#### 프로그래밍 언어의 구현 방법

- 컴파일러
  - 프로그램을 CPU가 수행할 수 있는 형태로 변환
  - 인터프리터가 하는 해석 과정을 미리 모두 수행 (효율적)
  - 상용 프로그램은 컴파일 방식으로 번역한 후 판매하는 것
    - 원래 소스는 알 수 없음
    - 보안에 부가적인 이점도 존재

- 인터프리터
  - 프로그래밍 언어로 작성된 고수준의 명령을 해석하여 수행하는 프로그램
  - 인터프리터는 CPU의 인출 - 해석 - 실행 주기를 흉내냄

- 하이브리드 구현
  - 인터프리터와 컴파일러 방식을 조합
  - 중간코드까지 컴파일한 후 인터프리터를 통해 해석
  - 중간코드는 기계어와 유사하기 때문에 인터프리터의 해석 속도가 훨씬 빨라짐
  - Java가 대표적인 예시
  - 컴파일 후 JVM 위에서 실행

