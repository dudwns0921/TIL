# 운영체제

## 가상 메모리

### 연속 메모리 할당

- 메모리 크기보다 더 큰 기억공간이 필요한 프로세스는 실행 불가

### 가상 메모리

- 메모리 크기보다 더 큰 기억공간이 필요한 프로세스도 실행할 수 있게 하는 방법
- 전체 프로세스가 아닌 실행에 필요한 부분만 메모리에 올려진다면 실행 자체는 가능.
- 실행 중인 프로세스에 의해 참조되는 주소를 메모리에서 사용하는 주소와 분리
- 프로세스가 사용하는 가상주소 공간
- 메모리가 실제로 사용하는 실주소 공간
- 가상주소를 실주소로 사상이 필요함
- 메모리에 올라오지 않은 나머지 가상주소 공간은 보조기억장치를 활용
- 필요할 때마다 메모리상에 올려서 동작 실행

### 사상

- 프로세스 실행을 위해 가상주소를 실주소로 변환하는 과정
- 동적 주소변환(DAT): 프로세스가 실행되는 동안 사상
- 주소변환 자체는 사전에 이루어질 수 없음
- 인위적 연속성
  - 가상주소 공간에서 연속적인 주소가 실주소 공간에서도 연속적일 필요는 없음

## 블록 단위 주소 변환

### 주소 변환

- 주소 변환 사상표
  - 동적 주소변환을 위한 정보를 가진 표
  - 주소변환이나 바이트나 워드 단위로 이뤄지면 변환에 필요한 정보량이 너무 많아 비효율적임

### 블록 사상 시스템

- 블록 단위로 주소변환
- 가상 메모리의 각 블록이 메모리의 어디에 위치하는지 관리
- 가상주소 v = (b,d)
- b 블록 번호
- d 블록의 시작점으로부터 변위, 얼마나 떨어져 있는지
- 사상표에 있는 정보는 b가 b'으로 변환되어있다는 정보
- 실주소의 b'에서 d만큼 떨어진 곳, 실주소를 얻어낼 수 있음

- 블록의 크기는 적절히 정해야 함
  - 크기가 커질수록
    - 사상표 크기 감소
    - 블록 전송시간 증가, 동시에 적재할 프로세스 수 감소
  - 크기가 작아질수록
    - 사상표 크기 증가
    - 블록 전송시간 감소, 동시에 적재할 프로세스 수 증가

### 블록 구성방식

- 페이지
  - 블록의 크기가 동일
- 세그먼트
  - 블록의 크기가 다를 수 있음

### 페이징 기법

- 가상 메모리를 페이지 단위로 나누어 관리하는 기법
- 메모리 영역도 페이지와 동일한 크기의 페이지 프레임으로 나눔
  - 페이지 프레임 : 페이지를 담을 수 있는 틀
- 페이징 사상표
  - 가상주소를 실주소로 동적 변환할 수 있게 함
  - 페이지 번호에 대한 페이지 프레임 번호 저장
  - 페이지 번호는 실제로 저장되어있지는 않고 인덱스로 사용됨
  - 배열의 인덱스가 배열에 저장되는 게 아닌 것과 동일
  - 사상표 정보
    - 인덱스로 사용되는 페이지 번호
    - 페이지 존재 비트
    - 보조기억장치 주소
    - 페이지 프레임 번호
  - 어떤 페이지 번호가 어떤 페이지 프레임 번호로 가는지가 가장 핵심적인 정보
- 직접 사상에 의한 동적 주소변환
  - 페이지 사상표를 직접 이용
  - 사상 과정
    - 페이지 크기 M = 1024
    - 가상주소 v = (3,8)
    - 페이지 사상표에서 인덱스 3으로 이동
    - 페이지 존재 비트 확인, 1일 경우 메모리에 존재
    - 페이지 프레임 번호 확인
    - 실주소 r = 5M+8(변위 값)

- 연관사상에 의한 동적 주소변환
  - 페이지 변환 정보를 연관 메모리에 저장한 연관사상표를 이용
  - 직접 사상표에서는 페이지 번호는 직접적으로 저장되지 않고 인덱스로 사용됨
  - 하지만 연관 메모리에는 페이지 번호가 저장됨
  - 그래서 굉장히 빠르게 사상이 이루어짐
  - 원래는 순차적으로 검색하지만, 연관 메모리는 한 번에 살펴볼 수 있다는 장점이 있음

- 연관/직접 사상에 의한 동적 주소변환
  - 연관 메모리는 굉장히 고가
  - 연관사상표에는 가장 최근에 참조된 페이지만 보관
  - 연관사상표에 없을 때만 직접사상 이용
  - 둘을 함께 사용할 경우 먼저 연관 메모리에 있는지 확인하는 작업이 이루어짐

#### 페이징 기법의 특징

- 논리적 의미와 무관한 동일 크기의 페이지로 나눔
- 메모리 보호는 페이지 단위로 이루어짐
- 외부 단편화가 발생하지 않음
- 내부 단편화는 발생 가능
  - 같은 크기로 나누다보면 제일 마지막 페이지같은 경우에는 남는 공간이 발생 가능
  - 굉장히 미미한 수준 
- 메모리 관리 차원에서 좋다고 볼 수 있음

### 세그먼테이션 기법

- 가상 메모리를 세그먼트 단위로 나누어 관리하는 기법
  - 세그먼트 : 논리적 의미에 부합하는 다양한 크기의 블록
- 세그먼트 사상표를 이용해 동적 주소 변환
- 세그먼트 사상표
  - 세그먼트 번호는 페이지 번호와 동일하게 인덱스로 사용됨
  - 세그먼트 번호에 대한 실주소에서의 시작 위치 저장
  - 세그먼트 길이는 오버플로 확인용
  - 정보
    - 세그먼트 존재 비트
    - 보조기억장치 주소
    - 세그먼트 길이(페이지 길이와 동일)
    - 세그먼트 시작주소
    - 시작주소와 길이가 있기 때문에 메모리 보호가 가능
- 페이징/세그먼테잇현 혼용기법
  - 세그먼테이션 기법의 논리적 장점과 페이징 기법의 메모리 관리 측면의 장점
  - 가상 메모리를 세그먼트 단위로 분할 후 각 세그먼트를 다시 페이지 단위로 분할
  - 메모리는 페이지 프레임으로 분할
  - 가상주소 v = (s,p,d)
  - s 세그먼트 번호, p 페이지 번호, d 페이지 내 변위
  - 혼용될 경우 세그먼트 사상표에 저장된 주소값은 페이지 사상표의 주소값(인덱스)

## 메모리 호출기법

- 어느 시점에 페이지 또는 세그먼트를 메모리에 적재할 것인가를 결정하는 기법
- 페이징 기법에서의 호출기법 종류
  - 요구 페이지 호출기법
    - 프로세스의 페이지 요구가 있을 떄 요구된 페이지를 메모리에 적재하는 방법
    - 옮길 페이지 결정에 대한 오버헤드 최소화
    - 적재된 페이지는 실제로 참조됨
    - 프로세스 시작 시점에는 연속적으로 페이지 부재 발생
  - 예상 페이지 호출기법
    - 곧 사용될 것으로 예상되는 페이지를 미리 메모리에 적재하는 방법
    - 예상이 잘못된 경우 시간과 메모리 공간 낭비
    - 프로세스 시작 시점에 적용하면 성능이 개선됨
